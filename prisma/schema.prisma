generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Bot {
  id           String      @id @default(cuid())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  name         String      @unique
  avatarUrl    String?
  status       BotStatus   @default(Active)
  token        String /// @encrypted
  clientId     String /// @encrypted
  clientSecret String /// @encrypted
  community    Community   @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId  String      @unique
  permissions  BotRole[]
  servers      BotServer[]
  logs         Log[]
}

model BotRole {
  id           String           @id @default(cuid())
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  bot          Bot              @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId        String
  serverId     String
  serverRoleId String
  permissions  RolePermission[]

  @@unique([botId, serverId, serverRoleId])
}

model BotServer {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  bot            Bot      @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId          String
  serverId       String
  dryRun         Boolean  @default(true)
  verbose        Boolean  @default(false)
  adminRole      String?
  commandChannel String?

  @@unique([botId, serverId])
}

model Community {
  id          String            @id @default(cuid())
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  name        String
  avatarUrl   String?
  description String?
  websiteUrl  String?
  discordUrl  String?
  githubUrl   String?
  twitterUrl  String?
  telegramUrl String?
  members     CommunityMember[]
  roles       Role[]
  cluster     NetworkCluster
  bot         Bot?
  logs        Log[]

  // TODO: Add relation to NetworkToken
  @@unique([name])
}

model CommunityMember {
  id          String                @id @default(cuid())
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  role        CommunityRole
  community   Community             @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId String
  user        User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  roles       CommunityMemberRole[]

  @@unique([communityId, userId])
}

model CommunityMemberRole {
  id        String          @id @default(cuid())
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt
  member    CommunityMember @relation(fields: [memberId], references: [id])
  memberId  String
  role      Role            @relation(fields: [roleId], references: [id])
  roleId    String
}

model Identity {
  id           String              @id @default(cuid())
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  syncStarted  DateTime?
  syncEnded    DateTime?
  provider     IdentityProvider
  providerId   String
  name         String
  accessToken  String? /// @encrypted
  refreshToken String? /// @encrypted
  profile      Json?
  verified     Boolean             @default(false)
  owner        User                @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId      String
  challenges   IdentityChallenge[]
  logs         Log[]

  @@unique([provider, providerId])
}

model IdentityChallenge {
  id         String           @id @default(cuid())
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  challenge  String           @unique
  signature  String?
  ip         String
  userAgent  String
  verified   Boolean          @default(false)
  identity   Identity         @relation(fields: [provider, providerId], references: [provider, providerId], onDelete: Cascade)
  provider   IdentityProvider
  providerId String
}

model Log {
  id                 String            @id @default(cuid())
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt
  message            String
  data               Json?
  level              LogLevel
  relatedId          String?
  relatedType        LogRelatedType?
  community          Community?        @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId        String?
  identity           Identity?         @relation(fields: [identityProvider, identityProviderId], references: [provider, providerId], onDelete: Cascade)
  identityProvider   IdentityProvider?
  identityProviderId String?
  bot                Bot?              @relation(fields: [botId], references: [id], onDelete: Cascade)
  botId              String?
  networkAsset       NetworkAsset?     @relation(fields: [networkAssetId], references: [id], onDelete: Cascade)
  networkAssetId     String?
  user               User?             @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId             String?
  role               Role?             @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId             String?
}

model Network {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  updatedAt DateTime       @default(now()) @updatedAt
  cluster   NetworkCluster @unique
  type      NetworkType
  name      String         @unique
  endpoint  String
  assets    NetworkAsset[]
  tokens    NetworkToken[]
}

model NetworkAsset {
  id         String           @id @default(cuid())
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
  network    Network          @relation(fields: [cluster], references: [cluster])
  cluster    NetworkCluster
  resolver   NetworkResolver
  type       NetworkTokenType
  account    String
  group      String?
  name       String
  symbol     String?
  balance    String?
  decimals   Int
  mint       String
  owner      String
  program    String?
  imageUrl   String?
  metadata   Json?
  attributes Json?
  logs       Log[]

  @@unique([account, cluster])
  @@index([cluster, owner, type])
  @@index([cluster, group, type])
}

model NetworkToken {
  id          String           @id @default(cuid())
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  network     Network          @relation(fields: [cluster], references: [cluster])
  cluster     NetworkCluster
  type        NetworkTokenType
  name        String
  account     String
  program     String
  vault       String?
  imageUrl    String?
  metadataUrl String?
  description String?
  symbol      String?
  raw         Json?
  conditions  RoleCondition[]

  @@unique([account, cluster])
}

model Role {
  id          String                @id @default(cuid())
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt
  community   Community             @relation(fields: [communityId], references: [id], onDelete: Cascade)
  communityId String
  name        String
  conditions  RoleCondition[]
  permissions RolePermission[]
  members     CommunityMemberRole[]
  logs        Log[]
}

model RoleCondition {
  id        String           @id @default(cuid())
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  type      NetworkTokenType
  amount    String           @default("0")
  config    Json?
  filters   Json?
  name      String
  token     NetworkToken     @relation(fields: [tokenId], references: [id])
  tokenId   String
  role      Role             @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId    String
}

model RolePermission {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  role      Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId    String
  botRole   BotRole? @relation(fields: [botRoleId], references: [id], onDelete: Cascade)
  botRoleId String?

  @@unique([roleId, botRoleId])
}

model User {
  id          String            @id @default(cuid())
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  lastLogin   DateTime?
  avatarUrl   String?
  developer   Boolean           @default(false)
  name        String?
  password    String? /// @encrypted
  role        UserRole          @default(User)
  status      UserStatus        @default(Created)
  username    String            @unique
  communities CommunityMember[]
  identities  Identity[]
  logs        Log[]
}

enum BotStatus {
  Active
  Inactive
}

enum CommunityRole {
  Admin
  Member
}

enum IdentityProvider {
  Discord
  Solana
}

enum LogLevel {
  Error
  Info
  Verbose
  Warning
}

enum LogRelatedType {
  Bot
  BotMember
  Community
  Identity
  Role
  User
}

enum NetworkCluster {
  SolanaCustom
  SolanaDevnet
  SolanaMainnet
  SolanaTestnet
}

enum NetworkResolver {
  Anybodies
  SolanaFungible
  SolanaNonFungible
}

enum NetworkTokenType {
  Fungible
  NonFungible
}

enum NetworkType {
  Solana
}

enum UserRole {
  Admin
  User
}

enum UserStatus {
  Active
  Created
  Inactive
}
